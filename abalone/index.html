<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Abalone Original (Mouvement Am√©lior√©)</title>
    <style>
        /* Styles inchang√©s pour le visuel Hexagonal */
        body {
            font-family: Arial, sans-serif;
            background-color: #1a1a2e;
            color: #e0e0e0;
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            padding: 20px;
            user-select: none;
        }
        h1 { color: #00ff99; margin-bottom: 5px; }
        
        #game-area {
            position: relative;
            width: 600px;
            height: 520px;
            margin: 20px 0;
            border: 5px solid #6441a5; 
            border-radius: 10px;
            background-color: #333;
        }
        .position {
            position: absolute;
            width: 30px; 
            height: 30px;
            border-radius: 50%;
            background-color: #111; 
            border: 2px solid #222;
            cursor: pointer;
            display: flex;
            justify-content: center;
            align-items: center;
            transform: translate(-50%, -50%); 
            z-index: 10;
        }
        
        /* BILLE ROUGE ET BLANCHE (Rouge au lieu de Noir pour l'esth√©tique) */
        .marble {
            width: 28px;
            height: 28px;
            border-radius: 50%;
            cursor: pointer;
            z-index: 20;
            box-shadow: inset 0 0 5px rgba(255, 255, 255, 0.5), 0 0 8px rgba(0, 0, 0, 0.5);
            /* Ajout d'une transition pour le mouvement */
            transition: transform 0.3s ease-in-out;
        }
        
        .white { 
            background: radial-gradient(circle at 10px 10px, #fff, #bbb);
            border: 1px solid #777; 
        }
        .red { 
            background: radial-gradient(circle at 10px 10px, #FF4136, #A00000); /* Chang√© √† Rouge */
            border: 1px solid #777;
        }
        
        .selected { 
            box-shadow: 0 0 15px #FF8C00, inset 0 0 5px rgba(255, 255, 0, 0.8);
            border-color: #FF8C00 !important;
        }
        
        /* Statut et Compteurs */
        #status { font-size: 1.2em; margin: 15px 0; min-height: 30px; color: #FFDC00; }
        #counters { display: flex; justify-content: space-around; width: 400px; margin-bottom: 10px; }
        button { background-color: #00ff99; border: none; color: #1a1a2e; padding: 10px 20px; font-size: 1em; font-weight: bold; border-radius: 5px; cursor: pointer; margin: 5px; }
        a { display: inline-block; margin-top: 15px; color: #00ff99; text-decoration: none; font-size: 1.1em; }
    </style>
</head>
<body>

    <h1>Abalone (Rouge vs Blanc)</h1>
    
    <div id="counters">
        <span id="white-out">Billes Blanches √âject√©es : 0/6</span>
        <span id="red-out">Billes Rouges √âject√©es : 0/6</span>
    </div>
    
    <div id="status"></div>
    
    <div id="game-area"></div>
    
    <div>
        <button id="restartButton">Nouvelle Partie</button>
        <a href="../index.html">Retour au menu</a>
    </div>

    <script>
        const gameArea = document.getElementById('game-area');
        const statusElement = document.getElementById('status');
        const whiteOutCounter = document.getElementById('white-out');
        const redOutCounter = document.getElementById('red-out');
        const restartButton = document.getElementById('restartButton');

        const TILE_RADIUS = 28;
        const MARGIN_X = 300;
        const MARGIN_Y = 260;
        const SQRT3 = Math.sqrt(3);
        const WIN_COUNT = 6; 

        let boardState = {}; 
        let currentPlayer = 'white'; // Blanc commence
        let selectedMarbles = [];
        let ejectedCount = { white: 0, red: 0 };
        let gameActive = false;

        const ALL_POSITIONS = [
            { q: -4, r: 4 }, { q: -3, r: 4 }, { q: -2, r: 4 }, { q: -1, r: 4 }, { q: 0, r: 4 },
            { q: -4, r: 3 }, { q: -3, r: 3 }, { q: -2, r: 3 }, { q: -1, r: 3 }, { q: 0, r: 3 }, { q: 1, r: 3 },
            { q: -4, r: 2 }, { q: -3, r: 2 }, { q: -2, r: 2 }, { q: -1, r: 2 }, { q: 0, r: 2 }, { q: 1, r: 2 }, { q: 2, r: 2 },
            { q: -4, r: 1 }, { q: -3, r: 1 }, { q: -2, r: 1 }, { q: -1, r: 1 }, { q: 0, r: 1 }, { q: 1, r: 1 }, { q: 2, r: 1 }, { q: 3, r: 1 },
            { q: -4, r: 0 }, { q: -3, r: 0 }, { q: -2, r: 0 }, { q: -1, r: 0 }, { q: 0, r: 0 }, { q: 1, r: 0 }, { q: 2, r: 0 }, { q: 3, r: 0 }, { q: 4, r: 0 },
            { q: -3, r: -1 }, { q: -2, r: -1 }, { q: -1, r: -1 }, { q: 0, r: -1 }, { q: 1, r: -1 }, { q: 2, r: -1 }, { q: 3, r: -1 }, { q: 4, r: -1 },
            { q: -2, r: -2 }, { q: -1, r: -2 }, { q: 0, r: -2 }, { q: 1, r: -2 }, { q: 2, r: -2 }, { q: 3, r: -2 }, { q: 4, r: -2 },
            { q: -1, r: -3 }, { q: 0, r: -3 }, { q: 1, r: -3 }, { q: 2, r: -3 }, { q: 3, r: -3 }, { q: 4, r: -3 },
            { q: 0, r: -4 }, { q: 1, r: -4 }, { q: 2, r: -4 }, { q: 3, r: -4 }, { q: 4, r: -4 },
        ];

        const HEX_DIRECTIONS = [
            { q: 1, r: 0 }, { q: 1, r: -1 }, { q: 0, r: -1 }, 
            { q: -1, r: 0 }, { q: -1, r: 1 }, { q: 0, r: 1 }
        ];
        
        function hexToPixel(q, r) {
            const x = TILE_RADIUS * (SQRT3 * q + SQRT3 / 2 * r);
            const y = TILE_RADIUS * (3 / 2 * r);
            return { x: x + MARGIN_X, y: y + MARGIN_Y };
        }

        function initialLayout(q, r) {
            const key = `${q},${r}`;
            // Zones de placement standard pour 14 billes (Rouge est au Nord)
            const redZone = ["0,4", "-1,4", "-2,4", "-3,4", "-4,4", "1,3", "0,3", "-1,3", "-2,3", "-3,3", "2,2", "1,2", "0,2", "-1,2"];
            const whiteZone = ["4,-4", "3,-4", "2,-4", "1,-4", "0,-4", "4,-3", "3,-3", "2,-3", "1,-3", "0,-3", "2,-2", "1,-2", "0,-2", "-1,-3"]; 
            
            if (redZone.includes(key)) return 'red';
            if (whiteZone.includes(key)) return 'white';
            return 0;
        }

        // --- Logique du Jeu ---

        function initializeGame() {
            gameArea.innerHTML = '';
            boardState = {};
            selectedMarbles = [];
            currentPlayer = 'white';
            ejectedCount = { white: 0, red: 0 };
            gameActive = true;

            ALL_POSITIONS.forEach(pos => {
                const { q, r } = pos;
                const key = `${q},${r}`;
                const pixel = hexToPixel(q, r);

                const positionElement = document.createElement('div');
                positionElement.classList.add('position');
                positionElement.style.left = `${pixel.x}px`;
                positionElement.style.top = `${pixel.y}px`;
                positionElement.dataset.q = q;
                positionElement.dataset.r = r;
                positionElement.addEventListener('click', () => handlePositionClick(q, r));
                
                const player = initialLayout(q, r);
                boardState[key] = { player: player, element: positionElement };
                
                if (player !== 0) {
                    const marble = document.createElement('div');
                    marble.classList.add('marble', player);
                    positionElement.appendChild(marble);
                }

                gameArea.appendChild(positionElement);
            });
            
            updateStatus();
            updateCounters();
        }

        function renderBoard() {
            Object.values(boardState).forEach(state => {
                const marbleElement = state.element.querySelector('.marble');
                if (marbleElement) {
                    marbleElement.classList.remove('selected');
                }
            });

            selectedMarbles.forEach(([q, r]) => {
                const key = `${q},${r}`;
                const state = boardState[key];
                if (state && state.element) {
                    const marbleElement = state.element.querySelector('.marble');
                    if (marbleElement) {
                        marbleElement.classList.add('selected');
                    }
                }
            });
            updateCounters();
        }

        function isAdjacent(q1, r1, q2, r2) {
            const dq = q1 - q2;
            const dr = r1 - r2;
            return (Math.abs(dq) <= 1 && Math.abs(dr) <= 1 && Math.abs(dq + dr) <= 1);
        }

        function isAdjacentToGroup(q, r) {
            return selectedMarbles.some(([sq, sr]) => isAdjacent(q, r, sq, sr));
        }

        // D√©termine la direction d'un mouvement unitaire
        function getMovementDirection(targetQ, targetR) {
            if (selectedMarbles.length === 0) return null;
            const [q, r] = selectedMarbles[0];
            const dirQ = targetQ - q;
            const dirR = targetR - r;
            
            // On v√©rifie que c'est bien une des 6 directions unitaires
            for (const dir of HEX_DIRECTIONS) {
                 if (dir.q === dirQ && dir.r === dirR) return dir;
            }
            return null;
        }

        // V√©rifie si le groupe est align√© dans la direction du mouvement
        function isGroupAligned(direction) {
            if (selectedMarbles.length === 1) return true; // Toujours align√©

            // V√©rifie si la direction du mouvement est parall√®le ou perpendiculaire √† l'alignement des billes s√©lectionn√©es
            const [q1, r1] = selectedMarbles[0];
            const [q2, r2] = selectedMarbles[1];
            
            const alignQ = q2 - q1;
            const alignR = r2 - r1;

            // Mouvement en ligne (Sumito): le vecteur d'alignement est parall√®le √† la direction
            if ((alignQ === direction.q && alignR === direction.r) || (alignQ === -direction.q && alignR === -direction.r)) {
                 return 'INLINE';
            }
            
            // Mouvement lat√©ral (Broadside): le vecteur d'alignement est perpendiculaire √† la direction
            // (Simplification : on autorise le mouvement lat√©ral s'il n'y a pas de bille devant)
            // C'est tr√®s difficile √† v√©rifier, on va supposer 'LATERAL' si ce n'est pas INLINE.
            return 'LATERAL';
        }

        // --- Logique de Pouss√©e/D√©placement (Am√©lior√©e) ---

        function tryMove(direction) {
            if (selectedMarbles.length === 0) return false;
            
            selectedMarbles.sort((a, b) => (a[0] * direction.q + a[1] * direction.r) - (b[0] * direction.q + b[1] * direction.r)); // Tri dans le sens du mouvement
            
            const alignment = isGroupAligned(direction);
            const [frontQ, frontR] = selectedMarbles[selectedMarbles.length - 1];
            const nextKey = `${frontQ + direction.q},${frontR + direction.r}`;
            
            const nextState = boardState[nextKey] || { player: 'off-board' }; // Voisin ou hors plateau

            // 1. D√©placement Simple (cible vide)
            if (nextState.player === 0) {
                 performInlineMove(direction);
                 return true;
            }
            
            // 2. Cible Amie (Mouvement Lat√©ral)
            if (nextState.player === currentPlayer) {
                 if (alignment === 'LATERAL') {
                      performInlineMove(direction);
                      return true;
                 }
                 // Sinon, mouvement bloqu√©
                 statusElement.textContent = "Mouvement bloqu√© par une bille amie.";
                 return false;
            }

            // 3. Pouss√©e (cible adverse)
            if (nextState.player !== 0 && nextState.player !== currentPlayer) {
                 if (alignment === 'INLINE') {
                     return tryPush(direction, [frontQ + direction.q, frontR + direction.r]);
                 }
                 // Pouss√©e lat√©rale interdite
                 statusElement.textContent = "Pouss√©e lat√©rale interdite. Utilisez un mouvement en ligne.";
                 return false;
            }
            
            // 4. Hors Plateau
            if (nextState.player === 'off-board') {
                 // Si c'est un mouvement en ligne, on tente la pouss√©e pour l'√©jection
                 if (alignment === 'INLINE') {
                     return tryPush(direction, [frontQ + direction.q, frontR + direction.r]);
                 }
                 statusElement.textContent = "Mouvement hors plateau bloqu√©.";
                 return false;
            }

            return false;
        }

        function performInlineMove(direction) {
             // D√©place de l'arri√®re vers l'avant
             for (let i = selectedMarbles.length - 1; i >= 0; i--) {
                const [q, r] = selectedMarbles[i];
                const newQ = q + direction.q;
                const newR = r + direction.r;
                const key = `${q},${r}`;
                const newKey = `${newQ},${newR}`;
                
                const marble = boardState[key].element.querySelector('.marble');
                
                // Met √† jour la bille
                if (boardState[newKey] && boardState[key]) {
                    boardState[newKey].player = boardState[key].player;
                    boardState[newKey].element.appendChild(marble);
                }

                // Vide l'ancienne position
                if (boardState[key]) {
                    boardState[key].player = 0;
                    boardState[key].element.innerHTML = '';
                }
             }
        }
        
        function tryPush(direction, startPos) {
            const opponent = currentPlayer === 'white' ? 'red' : 'white';
            let pushCount = 0;
            let currentQ = startPos[0];
            let currentR = startPos[1];
            let opponentLine = [];

            // 1. Compte la ligne adverse
            while (isOnBoard(currentQ, currentR) && boardState[`${currentQ},${currentR}`] && boardState[`${currentQ},${currentR}`].player === opponent) {
                opponentLine.push([currentQ, currentR]);
                pushCount++;
                currentQ += direction.q;
                currentR += direction.r;
            }
            
            // 2. R√®gle de Pouss√©e : Taille Joueur > Taille Opposant (et max 3 billes)
            if (selectedMarbles.length > pushCount && selectedMarbles.length <= 3 && pushCount > 0) {
                // 2.1. D√©place la cha√Æne adverse + √©jection
                for (let i = opponentLine.length - 1; i >= 0; i--) {
                    const [q, r] = opponentLine[i];
                    const key = `${q},${r}`;
                    const newQ = q + direction.q;
                    const newR = r + direction.r;
                    const newKey = `${newQ},${newR}`;

                    const marble = boardState[key].element.querySelector('.marble');

                    if (!isOnBoard(newQ, newR)) { // Hors plateau -> √âjection
                         ejectedCount[opponent]++;
                         boardState[key].player = 0;
                         boardState[key].element.innerHTML = '';
                    } else {
                         // D√©place bille adverse
                         boardState[newKey].player = opponent;
                         boardState[newKey].element.appendChild(marble);
                         boardState[key].player = 0;
                         boardState[key].element.innerHTML = '';
                    }
                 }

                 // 2.2. D√©place le groupe du joueur
                 performInlineMove(direction);
                
                 if (ejectedCount[opponent] >= WIN_COUNT) {
                     endGame(currentPlayer);
                 }
                 
                 return true;
            }
            statusElement.textContent = `Pouss√©e impossible : ${selectedMarbles.length} contre ${pushCount} ou trop de billes.`;
            return false;
        }

        // --- Fonctions de Contr√¥le ---

        function switchTurn() {
            selectedMarbles = []; 
            currentPlayer = currentPlayer === 'white' ? 'red' : 'white';
            renderBoard();
            updateStatus();
        }
        
        function endGame(winner) {
            gameActive = false;
            let winnerColor = winner.toUpperCase();
            statusElement.textContent = `üèÜ FIN : Le joueur ${winnerColor} a gagn√© en √©jectant ${WIN_COUNT} billes adverses !`;
        }

        function updateStatus() {
            statusElement.textContent = `Au tour de ${currentPlayer.toUpperCase()}. S√©lectionnez une √† trois billes adjacentes.`;
            whiteOutCounter.textContent = `Billes Blanches √âject√©es : ${ejectedCount.white}/${WIN_COUNT}`;
            redOutCounter.textContent = `Billes Rouges √âject√©es : ${ejectedCount.red}/${WIN_COUNT}`;
        }

        // --- √âv√©nements ---
        restartButton.addEventListener('click', initializeGame);
        
        // Lancement du jeu au chargement de la page
        initializeGame();
    </script>
</body>
</html>
