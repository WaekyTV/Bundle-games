<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Abalone Simplifi√©</title>
    <style>
        /* Th√®me sombre coh√©rent */
        body {
            font-family: Arial, sans-serif;
            background-color: #1a1a2e;
            color: #e0e0e0;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            margin: 0;
            padding: 20px;
            user-select: none;
        }
        h1 {
            color: #00ff99; /* Vert n√©on */
        }
        
        /* Plateau de jeu (carr√© 5x5 pour la simplification) */
        #board {
            display: grid;
            grid-template-columns: repeat(5, 60px);
            grid-template-rows: repeat(5, 60px);
            border: 4px solid #6441a5;
            margin: 20px 0;
        }
        
        /* Case (trou) */
        .square {
            width: 60px;
            height: 60px;
            background-color: #2e2e4d;
            border: 1px solid #444;
            display: flex;
            justify-content: center;
            align-items: center;
            position: relative;
        }
        
        /* Bille (Piece) */
        .marble {
            width: 50px;
            height: 50px;
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 0 5px rgba(0, 0, 0, 0.5);
            transition: border 0.1s;
        }
        .white { background-color: #fff; border: 3px solid #ccc; } /* Joueur 1 (Blanc) */
        .black { background-color: #000; border: 3px solid #333; } /* Joueur 2 (Noir) */
        
        /* Bille s√©lectionn√©e */
        .selected { 
            border: 4px solid #FF8C00; /* Orange r√©tro pour la s√©lection */
            transform: scale(1.1);
        }
        
        /* Indicateur de tour et statut */
        #status {
            font-size: 1.2em;
            margin: 15px 0;
            min-height: 30px;
            color: #FFDC00;
            text-align: center;
        }
        
        /* Compteurs */
        #counters {
            display: flex;
            justify-content: space-around;
            width: 300px;
            margin-bottom: 10px;
        }

        /* Boutons et lien */
        button {
            background-color: #00ff99;
            border: none;
            color: #1a1a2e;
            padding: 10px 20px;
            font-size: 1em;
            font-weight: bold;
            border-radius: 5px;
            cursor: pointer;
            margin: 5px;
        }
        a {
            display: inline-block;
            margin-top: 15px;
            color: #00ff99;
            text-decoration: none;
            font-size: 1.1em;
        }
    </style>
</head>
<body>

    <h1>Abalone (Simplifi√© 5x5)</h1>
    
    <div id="counters">
        <span id="white-out">Billes Blanches √âject√©es : 0/2</span>
        <span id="black-out">Billes Noires √âject√©es : 0/2</span>
    </div>
    
    <div id="status"></div>
    
    <div id="board">
        </div>
    
    <button id="restartButton">Nouvelle Partie</button>
    <a href="../index.html">Retour au menu</a>

    <script>
        const SIZE = 5;
        const WIN_COUNT = 2; // Gagne en √©jectant 2 billes
        const boardElement = document.getElementById('board');
        const statusElement = document.getElementById('status');
        const restartButton = document.getElementById('restartButton');
        const whiteOutCounter = document.getElementById('white-out');
        const blackOutCounter = document.getElementById('black-out');

        let boardState = [];
        let currentPlayer = 'white';
        let selectedMarbles = []; // Tableau de [row, col] des billes s√©lectionn√©es
        let ejectedCount = { white: 0, black: 0 };
        let gameActive = false;

        // --- Initialisation ---

        function initializeGame() {
            boardElement.innerHTML = '';
            boardState = [];
            selectedMarbles = [];
            currentPlayer = 'white';
            ejectedCount = { white: 0, black: 0 };
            gameActive = true;

            // Initialiser le boardState (Billes sur les lignes ext√©rieures 5x5)
            for (let r = 0; r < SIZE; r++) {
                boardState[r] = [];
                for (let c = 0; c < SIZE; c++) {
                    let player = 0; // 0 = vide
                    if (r === 0 || r === 1) { // Lignes du haut (Noir)
                        player = 'black';
                    } else if (r === SIZE - 1 || r === SIZE - 2) { // Lignes du bas (Blanc)
                        player = 'white';
                    }
                    boardState[r][c] = player;
                }
            }
            
            renderBoard();
            updateStatus();
            updateCounters();
        }

        // Dessine la grille et les billes
        function renderBoard() {
            boardElement.innerHTML = '';
            for (let r = 0; r < SIZE; r++) {
                for (let c = 0; c < SIZE; c++) {
                    const square = document.createElement('div');
                    square.classList.add('square');
                    square.dataset.row = r;
                    square.dataset.col = c;
                    
                    const player = boardState[r][c];
                    
                    if (player !== 0) {
                        const marble = document.createElement('div');
                        marble.classList.add('marble', player);
                        
                        // Si la bille est s√©lectionn√©e, applique le style
                        const isSelected = selectedMarbles.some(m => m[0] === r && m[1] === c);
                        if (isSelected) {
                            marble.classList.add('selected');
                        }
                        
                        marble.addEventListener('click', () => handleSquareClick(r, c));
                        square.appendChild(marble);
                    } else {
                        // Ajoute un √©couteur au trou vide si une bille est s√©lectionn√©e
                         square.addEventListener('click', () => handleSquareClick(r, c));
                    }
                    boardElement.appendChild(square);
                }
            }
        }
        
        // Met √† jour le statut et les compteurs
        function updateStatus() {
            statusElement.textContent = gameActive 
                ? `Au tour de ${currentPlayer.toUpperCase()}. S√©lectionnez 1, 2 ou 3 billes.` 
                : statusElement.textContent;
        }
        
        function updateCounters() {
            whiteOutCounter.textContent = `Billes Blanches √âject√©es : ${ejectedCount.white}/${WIN_COUNT}`;
            blackOutCounter.textContent = `Billes Noires √âject√©es : ${ejectedCount.black}/${WIN_COUNT}`;
        }

        // --- Logique de Clic ---

        function handleSquareClick(r, c) {
            if (!gameActive) return;

            const player = boardState[r][c];
            
            // 1. Clic sur une bille du joueur actuel (S√©lection/D√©s√©lection)
            if (player === currentPlayer) {
                const index = selectedMarbles.findIndex(m => m[0] === r && m[1] === c);
                
                if (index !== -1) {
                    selectedMarbles.splice(index, 1); // D√©s√©lectionner
                } else if (selectedMarbles.length < 3) {
                    // Si on clique sur une bille adjacente aux autres billes s√©lectionn√©es, on l'ajoute
                    if (selectedMarbles.length === 0 || isAdjacent(r, c, selectedMarbles)) {
                         selectedMarbles.push([r, c]); // S√©lectionner
                    } else {
                         statusElement.textContent = "Les billes s√©lectionn√©es doivent √™tre adjacentes.";
                    }
                }
            } 
            // 2. Clic sur une case vide ou adverse (Mouvement)
            else if (selectedMarbles.length > 0) {
                // Tente de faire un mouvement
                if (tryMove(r, c)) {
                    // Mouvement r√©ussi, on change de tour
                    switchTurn();
                } else {
                    statusElement.textContent = "Mouvement invalide (Direction ou Pouss√©e impossible).";
                }
            }

            renderBoard(); // Rafra√Æchit l'affichage
        }

        // V√©rifie si la nouvelle bille est adjacente au groupe s√©lectionn√©
        function isAdjacent(r, c, group) {
            // Pour le 5x5, on v√©rifie si la nouvelle bille est voisine d'une des billes s√©lectionn√©es
            return group.some(([gr, gc]) => {
                const dr = Math.abs(r - gr);
                const dc = Math.abs(c - gc);
                // Voisin direct (diagonale incluse)
                return (dr <= 1 && dc <= 1) && (dr + dc > 0);
            });
        }
        
        // --- Logique de Mouvement (Simplifi√©e) ---
        
        function tryMove(tr, tc) {
            if (selectedMarbles.length === 0) return false;
            
            // Les billes s√©lectionn√©es doivent √™tre tri√©es pour d√©terminer la direction
            selectedMarbles.sort((a, b) => a[0] - b[0] || a[1] - b[1]);

            const sr = selectedMarbles[0][0]; // Ligne de la premi√®re bille
            const sc = selectedMarbles[0][1]; // Colonne de la premi√®re bille
            
            const lastR = selectedMarbles[selectedMarbles.length - 1][0];
            const lastC = selectedMarbles[selectedMarbles.length - 1][1];
            
            // D√©termine le vecteur de d√©placement (dr, dc)
            // tr, tc est la destination CLIQUEE (qui doit √™tre une case VIVE ou une bille ADVERSE)
            const dr = tr - sr;
            const dc = tc - sc;

            // Simplification: On ne g√®re que le mouvement d'une unit√© √† la fois
            if (Math.abs(dr) > 1 || Math.abs(dc) > 1 || (dr === 0 && dc === 0)) {
                return false;
            }
            
            // 1. Mouvement "en ligne" (D√©placement du groupe vers une case vide)
            // L'ensemble du groupe se d√©place de (dr, dc)
            const targetPos = [lastR + dr, lastC + dc];
            
            // V√©rifie que la case cible est vide
            if (boardState[targetPos[0]][targetPos[1]] === 0) {
                 // Effectue le d√©placement
                 performInlineMove(dr, dc);
                 return true;
            }

            // 2. Mouvement "de pouss√©e" (Push)
            const opponent = currentPlayer === 'white' ? 'black' : 'white';
            
            // V√©rifie si la case imm√©diatement apr√®s la fin du groupe est une bille adverse
            if (boardState[targetPos[0]][targetPos[1]] === opponent) {
                // Et que la taille du groupe est sup√©rieure √† la taille de la ligne adverse (Abalone rule: 2v1, 3v1, 3v2)
                if (selectedMarbles.length > 1) { // Simplifi√©: 2 billes peuvent pousser 1, 3 billes peuvent pousser 1 ou 2
                     return tryPush(dr, dc, targetPos, opponent);
                }
            }
            
            return false;
        }

        // Effectue un d√©placement simple (le groupe se d√©place dans l'espace libre)
        function performInlineMove(dr, dc) {
             // De la derni√®re bille √† la premi√®re bille (pour ne pas √©craser les billes)
             for (let i = selectedMarbles.length - 1; i >= 0; i--) {
                 const [r, c] = selectedMarbles[i];
                 const [tr, tc] = [r + dr, c + dc];
                 
                 boardState[tr][tc] = boardState[r][c]; // D√©place la bille
                 boardState[r][c] = 0; // Vide la case source
             }
        }
        
        // Tente de pousser une bille adverse
        function tryPush(dr, dc, startPos, opponent) {
            let pushCount = 0;
            let currentR = startPos[0];
            let currentC = startPos[1];

            // Compte combien de billes adverses sont align√©es
            while (currentR >= 0 && currentR < SIZE && currentC >= 0 && currentC < SIZE && boardState[currentR][currentC] === opponent) {
                pushCount++;
                currentR += dr;
                currentC += dc;
            }

            // Abalone Rule: Le groupe doit √™tre plus grand que la ligne √† pousser (Ex: 2v1, 3v1, 3v2)
            if (selectedMarbles.length > pushCount) {
                // Pouss√©e r√©ussie !
                
                // 1. D√©place la cha√Æne adverse (derni√®re bille √† la premi√®re bille)
                for (let i = pushCount - 1; i >= 0; i--) {
                    const r = startPos[0] + dr * i;
                    const c = startPos[1] + dc * i;
                    const tr = r + dr;
                    const tc = c + dc;

                    // V√©rifie si la derni√®re bille adverse est pouss√©e hors du plateau
                    if (i === pushCount - 1) {
                         if (tr < 0 || tr >= SIZE || tc < 0 || tc >= SIZE) {
                            ejectedCount[opponent]++; // Bille √©ject√©e
                         } else {
                            boardState[tr][tc] = boardState[r][c]; // D√©placement normal
                         }
                    } else {
                         boardState[tr][tc] = boardState[r][c];
                    }
                }

                // 2. D√©place le groupe du joueur sur la case de d√©part de la pouss√©e
                boardState[startPos[0]][startPos[1]] = currentPlayer;

                // 3. Vide l'ancienne position du groupe
                for (const [r, c] of selectedMarbles) {
                     boardState[r][c] = 0;
                }
                
                // V√©rifie la victoire
                if (ejectedCount[opponent] >= WIN_COUNT) {
                     endGame(currentPlayer);
                }
                
                return true;
            }
            return false;
        }


        // --- Fonctions de Contr√¥le ---

        function switchTurn() {
            selectedMarbles = []; // D√©s√©lectionner
            currentPlayer = currentPlayer === 'white' ? 'black' : 'white';
            renderBoard();
            updateStatus();
            updateCounters();
        }

        function endGame(winner) {
            gameActive = false;
            let winnerColor = winner.toUpperCase();
            statusElement.textContent = `üèÜ FIN : Le joueur ${winnerColor} a gagn√© en √©jectant ${WIN_COUNT} billes adverses !`;
            console.log(`Le joueur ${winnerColor} a gagn√© ! On enverra l'XP plus tard.`);
        }

        // --- √âv√©nements ---
        restartButton.addEventListener('click', initializeGame);
        
        // Lancement du jeu au chargement de la page
        initializeGame();
    </script>
</body>
</html>
