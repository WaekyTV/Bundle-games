<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Abalone Original (Hexagonal)</title>
    <style>
        /* Thème sombre cohérent */
        body {
            font-family: Arial, sans-serif;
            background-color: #1a1a2e;
            color: #e0e0e0;
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            padding: 20px;
            user-select: none;
        }
        h1 {
            color: #00ff99;
            margin-bottom: 5px;
        }
        
        #board-container {
            position: relative;
            width: 600px;
            height: 600px;
            margin: 20px 0;
            /* La bordure simule le plateau */
            border: 5px solid #6441a5; 
            border-radius: 10px;
            background-color: #333;
        }
        
        /* Style des positions (trous) */
        .position {
            position: absolute;
            width: 25px;
            height: 25px;
            border-radius: 50%;
            background-color: #222; /* Couleur du trou */
            border: 1px solid #444;
            cursor: pointer;
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 10;
        }
        
        /* Style des billes */
        .marble {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            cursor: pointer;
            z-index: 20;
            box-shadow: 0 0 5px rgba(0, 0, 0, 0.5);
        }
        .white { background-color: #fff; border: 2px solid #ccc; }
        .black { background-color: #000; border: 2px solid #111; }
        
        /* Bille sélectionnée */
        .selected { 
            box-shadow: 0 0 15px #FF8C00; /* Orange rétro */
            border-color: #FF8C00 !important;
        }
        
        /* Statut et Compteurs */
        #status {
            font-size: 1.2em;
            margin: 15px 0;
            min-height: 30px;
            color: #FFDC00;
        }
        #counters {
            display: flex;
            justify-content: space-around;
            width: 400px;
            margin-bottom: 10px;
        }
        
        /* Boutons et lien */
        button {
            background-color: #00ff99;
            border: none;
            color: #1a1a2e;
            padding: 10px 20px;
            font-size: 1em;
            font-weight: bold;
            border-radius: 5px;
            cursor: pointer;
            margin: 5px;
        }
        a {
            display: inline-block;
            margin-top: 15px;
            color: #00ff99;
            text-decoration: none;
            font-size: 1.1em;
        }
        a:hover {
            text-decoration: underline;
        }
    </style>
</head>
<body>

    <h1>Abalone (Plateau Hexagonal 61 Trous)</h1>
    
    <div id="counters">
        <span id="white-out">Billes Blanches Éjectées : 0/6</span>
        <span id="black-out">Billes Noires Éjectées : 0/6</span>
    </div>
    
    <div id="status"></div>
    
    <div id="board-container">
        </div>
    
    <div>
        <button id="restartButton">Nouvelle Partie</button>
        <a href="../index.html">Retour au menu</a>
    </div>

    <script>
        // --- CONFIGURATION DE LA GRILLE HEXAGONALE (Coord. Axiales) ---
        const boardContainer = document.getElementById('board-container');
        const statusElement = document.getElementById('status');
        const whiteOutCounter = document.getElementById('white-out');
        const blackOutCounter = document.getElementById('black-out');
        const restartButton = document.getElementById('restartButton');

        const TILE_RADIUS = 30; // Rayon pour le positionnement
        const MARGIN_X = 250;
        const MARGIN_Y = 250;
        const WIN_COUNT = 6; // Règle standard : 6 billes éjectées

        // Map: { "q,r": {player: 'white', element: node} }
        let boardState = {}; 
        let currentPlayer = 'white';
        let selectedMarbles = []; // Tableau de [q, r] des billes sélectionnées
        let ejectedCount = { white: 0, black: 0 };
        let gameActive = false;
        
        // Toutes les positions q,r du plateau Abalone (A1 à I9)
        const ALL_POSITIONS = [
            // Ligne A
            { q: -4, r: 4 }, { q: -3, r: 4 }, { q: -2, r: 4 }, { q: -1, r: 4 }, { q: 0, r: 4 },
            // Ligne B
            { q: -4, r: 3 }, { q: -3, r: 3 }, { q: -2, r: 3 }, { q: -1, r: 3 }, { q: 0, r: 3 }, { q: 1, r: 3 },
            // Ligne C
            { q: -4, r: 2 }, { q: -3, r: 2 }, { q: -2, r: 2 }, { q: -1, r: 2 }, { q: 0, r: 2 }, { q: 1, r: 2 }, { q: 2, r: 2 },
            // Ligne D
            { q: -4, r: 1 }, { q: -3, r: 1 }, { q: -2, r: 1 }, { q: -1, r: 1 }, { q: 0, r: 1 }, { q: 1, r: 1 }, { q: 2, r: 1 }, { q: 3, r: 1 },
            // Ligne E (Centre)
            { q: -4, r: 0 }, { q: -3, r: 0 }, { q: -2, r: 0 }, { q: -1, r: 0 }, { q: 0, r: 0 }, { q: 1, r: 0 }, { q: 2, r: 0 }, { q: 3, r: 0 }, { q: 4, r: 0 },
            // Ligne F
            { q: -3, r: -1 }, { q: -2, r: -1 }, { q: -1, r: -1 }, { q: 0, r: -1 }, { q: 1, r: -1 }, { q: 2, r: -1 }, { q: 3, r: -1 }, { q: 4, r: -1 },
            // Ligne G
            { q: -2, r: -2 }, { q: -1, r: -2 }, { q: 0, r: -2 }, { q: 1, r: -2 }, { q: 2, r: -2 }, { q: 3, r: -2 }, { q: 4, r: -2 },
            // Ligne H
            { q: -1, r: -3 }, { q: 0, r: -3 }, { q: 1, r: -3 }, { q: 2, r: -3 }, { q: 3, r: -3 }, { q: 4, r: -3 },
            // Ligne I
            { q: 0, r: -4 }, { q: 1, r: -4 }, { q: 2, r: -4 }, { q: 3, r: -4 }, { q: 4, r: -4 },
        ];

        // Directions hexagonales (déplacement d'une bille)
        const HEX_DIRECTIONS = [
            { q: 1, r: 0 }, { q: 1, r: -1 }, { q: 0, r: -1 }, 
            { q: -1, r: 0 }, { q: -1, r: 1 }, { q: 0, r: 1 }
        ];

        // --- Fonctions de Conversion et de Rendu ---
        
        // Convertit les coordonnées axiales (q, r) en pixels pour l'affichage
        function hexToPixel(q, r) {
            const x = TILE_RADIUS * (Math.sqrt(3) * q + Math.sqrt(3) / 2 * r);
            const y = TILE_RADIUS * (3 / 2 * r);
            return { x: x + MARGIN_X, y: y + MARGIN_Y };
        }

        // Initialise la position des billes de départ (position standard Abalone)
        function initialLayout(q, r) {
            const key = `${q},${r}`;
            const blackZone = ["0,4", "-1,4", "-2,4", "-3,4", "-4,4", 
                               "1,3", "0,3", "-1,3", "-2,3", "-3,3", 
                               "2,2", "1,2", "0,2", "-1,2"]; // Lignes A, B, C avant la D
            const whiteZone = ["4,-4", "3,-4", "2,-4", "1,-4", "0,-4",
                               "4,-3", "3,-3", "2,-3", "1,-3", "0,-3",
                               "4,-2", "3,-2", "2,-2", "1,-2"]; // Lignes I, H, G
            
            if (blackZone.includes(key)) return 'black';
            if (whiteZone.includes(key)) return 'white';
            return 0;
        }

        // --- Logique du Jeu ---

        function initializeGame() {
            boardContainer.innerHTML = '';
            boardState = {};
            selectedMarbles = [];
            currentPlayer = 'white';
            ejectedCount = { white: 0, black: 0 };
            gameActive = true;

            ALL_POSITIONS.forEach(pos => {
                const { q, r } = pos;
                const key = `${q},${r}`;
                const pixel = hexToPixel(q, r);

                // 1. Créer la position (le trou)
                const positionElement = document.createElement('div');
                positionElement.classList.add('position');
                positionElement.style.left = `${pixel.x}px`;
                positionElement.style.top = `${pixel.y}px`;
                positionElement.dataset.q = q;
                positionElement.dataset.r = r;
                positionElement.addEventListener('click', () => handlePositionClick(q, r));
                
                // 2. Placer la bille
                const player = initialLayout(q, r);
                boardState[key] = { player: player, element: positionElement };
                
                if (player !== 0) {
                    const marble = document.createElement('div');
                    marble.classList.add('marble', player);
                    positionElement.appendChild(marble);
                }

                boardContainer.appendChild(positionElement);
            });
            
            updateStatus();
            updateCounters();
            statusElement.textContent = "Blanc commence. Sélectionnez une à trois billes adjacentes.";
        }

        // Dessine la sélection et les billes
        function renderBoard() {
            Object.values(boardState).forEach(state => {
                const { player, element } = state;
                const marbleElement = element.querySelector('.marble');
                
                // Nettoyage de la sélection
                if (marbleElement) {
                    marbleElement.classList.remove('selected');
                }
            });

            // Applique la sélection
            selectedMarbles.forEach(([q, r]) => {
                const key = `${q},${r}`;
                const state = boardState[key];
                if (state && state.element) {
                    const marbleElement = state.element.querySelector('.marble');
                    if (marbleElement) {
                        marbleElement.classList.add('selected');
                    }
                }
            });
            updateCounters();
        }

        // Vérifie si une position (q, r) est sur le plateau
        function isOnBoard(q, r) {
            return ALL_POSITIONS.some(p => p.q === q && p.r === r);
        }

        // Vérifie si deux positions sont adjacentes
        function isAdjacent(q1, r1, q2, r2) {
            const dq = Math.abs(q1 - q2);
            const dr = Math.abs(r1 - r2);
            const ds = Math.abs((-q1 - r1) - (-q2 - r2)); // Coordonnée S
            return (dq <= 1 && dr <= 1 && ds <= 1) && (dq + dr + ds !== 0); // Voisin direct (distance max 1)
        }

        // --- Gestion des Clics ---

        function handlePositionClick(q, r) {
            if (!gameActive) return;
            
            const key = `${q},${r}`;
            const state = boardState[key];
            const isSelected = selectedMarbles.some(m => m[0] === q && m[1] === r);
            
            // 1. Clic sur une bille amie (Sélection)
            if (state && state.player === currentPlayer) {
                if (isSelected) {
                    selectedMarbles = selectedMarbles.filter(m => m[0] !== q || m[1] !== r);
                } else if (selectedMarbles.length < 3) {
                    // On ajoute seulement si le nouveau marbre est adjacent au groupe OU si le groupe est vide
                    if (selectedMarbles.length === 0 || isAdjacentToGroup(q, r)) {
                         selectedMarbles.push([q, r]);
                    }
                }
            }
            // 2. Clic sur une case vide ou adverse (Mouvement)
            else if (selectedMarbles.length > 0) {
                // Tente de trouver la direction de mouvement
                const direction = getMovementDirection(q, r);
                if (direction) {
                    if (tryMove(direction)) {
                        switchTurn();
                    }
                } else {
                    statusElement.textContent = "Mouvement invalide. Ciblez une case adjacente à la sélection.";
                }
            }

            renderBoard();
        }

        function isAdjacentToGroup(q, r) {
            return selectedMarbles.some(([sq, sr]) => isAdjacent(q, r, sq, sr));
        }

        // Détermine si le clic (q, r) définit un mouvement valide pour le groupe sélectionné
        function getMovementDirection(targetQ, targetR) {
            // Le déplacement doit être une unité dans une direction hexagonale (dr, dc)
            // L'ensemble du groupe doit bouger
            
            // On vérifie la position de la première bille du groupe (simplifié)
            if (selectedMarbles.length === 0) return null;
            const [q, r] = selectedMarbles[0];

            for (const dir of HEX_DIRECTIONS) {
                 const newQ = q + dir.q;
                 const newR = r + dir.r;
                 if (newQ === targetQ && newR === targetR) {
                      return dir; // C'est un mouvement valide
                 }
            }
            return null;
        }

        // --- Logique de Poussée/Déplacement ---

        function tryMove(direction) {
            // Tri du groupe sélectionné par rapport à la direction de mouvement
            selectedMarbles.sort((a, b) => {
                return (b[0] * direction.q + b[1] * direction.r) - (a[0] * direction.q + a[1] * direction.r);
            });
            
            // La bille la plus en avant dans la direction de mouvement
            const [frontQ, frontR] = selectedMarbles[selectedMarbles.length - 1];
            const nextQ = frontQ + direction.q;
            const nextR = frontR + direction.r;
            const nextKey = `${nextQ},${nextR}`;
            
            const nextState = boardState[nextKey];

            // 1. Cible non sur le plateau (Ejection tentée si le mouvement est "en ligne")
            if (!isOnBoard(nextQ, nextR)) {
                // Le mouvement est "en ligne" si la direction est la même que l'alignement des billes
                const isInline = selectedMarbles.length <= 1 || isGroupAligned(selectedMarbles, direction);
                if (isInline) {
                   return tryPush(direction, [frontQ, frontR]);
                }
                statusElement.textContent = "Mouvement latéral hors plateau invalide.";
                return false;
            }
            
            // 2. Déplacement Simple (cible vide)
            if (nextState.player === 0) {
                 performInlineMove(direction);
                 return true;
            }
            
            // 3. Poussée (cible adverse)
            if (nextState.player !== 0 && nextState.player !== currentPlayer) {
                 return tryPush(direction, [nextQ, nextR]);
            }
            
            // 4. Cible amie (Mouvement parallèle) ou bloqué
            statusElement.textContent = "Mouvement bloqué ou parallèle non géré dans cette version.";
            return false;
        }

        function isGroupAligned(group, direction) {
            // Pour être aligné, le déplacement d'une bille à l'autre doit être perpendiculaire à la direction
            // (Trop complexe à coder ici, simplifions : si le groupe est de taille 2 ou 3, on suppose qu'il est aligné)
            return group.length > 1; 
        }

        function performInlineMove(direction) {
            // Déplace de l'arrière vers l'avant (pour éviter d'écraser)
             for (let i = selectedMarbles.length - 1; i >= 0; i--) {
                const [q, r] = selectedMarbles[i];
                const key = `${q},${r}`;
                const newQ = q + direction.q;
                const newR = r + direction.r;
                const newKey = `${newQ},${newR}`;
                
                // Déplace la bille
                boardState[newKey].player = boardState[key].player;
                boardState[newKey].element.appendChild(boardState[key].element.querySelector('.marble'));

                // Vide l'ancienne position
                boardState[key].player = 0;
                boardState[key].element.innerHTML = ''; // Retirer la bille
             }
        }
        
        function tryPush(direction, startPos) {
            const opponent = boardState[`${startPos[0]},${startPos[1]}`].player;
            let pushCount = 0;
            let currentQ = startPos[0];
            let currentR = startPos[1];

            // Compte la ligne adverse
            while (isOnBoard(currentQ, currentR) && boardState[`${currentQ},${currentR}`] && boardState[`${currentQ},${currentR}`].player === opponent) {
                pushCount++;
                currentQ += direction.q;
                currentR += direction.r;
            }
            
            // Règle Abalone: Taille Joueur > Taille Opposant (2v1, 3v1, 3v2)
            if (selectedMarbles.length > pushCount && selectedMarbles.length <= 3) {
                 
                 // Déplace la chaîne adverse (poussée)
                 for (let i = pushCount - 1; i >= 0; i--) {
                    const q = startPos[0] + direction.q * i;
                    const r = startPos[1] + direction.r * i;
                    const newQ = q + direction.q;
                    const newR = r + direction.r;
                    const key = `${q},${r}`;
                    const newKey = `${newQ},${newR}`;

                    // Éjection (la bille est poussée hors du plateau)
                    if (!isOnBoard(newQ, newR)) {
                         ejectedCount[opponent]++;
                         boardState[key].player = 0;
                         boardState[key].element.innerHTML = '';
                    } else {
                         // Déplace bille adverse
                         boardState[newKey].player = boardState[key].player;
                         boardState[newKey].element.appendChild(boardState[key].element.querySelector('.marble'));
                         boardState[key].player = 0;
                         boardState[key].element.innerHTML = '';
                    }
                 }

                 // Déplace le groupe du joueur sur la case de départ de la poussée
                 const [oldQ, oldR] = selectedMarbles[selectedMarbles.length - 1]; // Position de la bille du joueur la plus avancée
                 boardState[oldQ + direction.q][oldR + direction.r].player = currentPlayer;
                 boardState[oldQ + direction.q][oldR + direction.r].element.appendChild(boardState[oldQ][oldR].element.querySelector('.marble'));


                 // 3. Vide l'ancienne position du groupe
                 for (const [r, c] of selectedMarbles) {
                     boardState[r][c].player = 0;
                     boardState[r][c].element.innerHTML = '';
                 }
                
                 // Vérifie la victoire
                 if (ejectedCount[opponent] >= WIN_COUNT) {
                     endGame(currentPlayer);
                 }
                 
                 return true;
            }
            statusElement.textContent = `Poussée impossible : ${selectedMarbles.length} contre ${pushCount}.`;
            return false;
        }

        // --- Fonctions de Contrôle ---

        function switchTurn() {
            selectedMarbles = []; 
            currentPlayer = currentPlayer === 'white' ? 'black' : 'white';
            renderBoard();
            updateStatus();
        }
        
        function endGame(winner) {
            gameActive = false;
            let winnerColor = winner.toUpperCase();
            statusElement.textContent = `🏆 FIN : Le joueur ${winnerColor} a gagné en éjectant ${WIN_COUNT} billes adverses !`;
            console.log(`Le joueur ${winnerColor} a gagné !`);
        }

        // --- Événements ---
        restartButton.addEventListener('click', initializeGame);
        
        // Lancement du jeu au chargement de la page
        initializeGame();
    </script>
</body>
</html>
