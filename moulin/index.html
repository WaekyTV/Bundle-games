<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Jeu du Moulin</title>
    <style>
        /* Thème sombre cohérent */
        body {
            font-family: Arial, sans-serif;
            background-color: #1a1a2e;
            color: #e0e0e0;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            margin: 0;
            padding: 10px;
            user-select: none;
        }
        h1 { color: #00ff99; }
        
        /* Conteneur et Plateau */
        #board-container {
            position: relative;
            width: 400px;
            height: 400px;
            margin: 20px;
            border: 5px solid #2e2e4d; /* Bordure interne pour l'esthétique */
            border-radius: 8px;
            background-color: #111;
        }

        /* Lignes de la Grille (Refonte: plus épaisses et néon) */
        .line {
            position: absolute;
            background-color: #027afa; /* Bleu néon */
            box-shadow: 0 0 5px #027afa;
        }
        /* Lignes Horizontales */
        .line.h { height: 4px; }
        .line.h1 { top: 10px; left: 10px; width: 380px; }
        .line.h2 { top: 136px; left: 136px; width: 128px; }
        .line.h3 { top: 200px; left: 10px; width: 380px; }
        .line.h4 { bottom: 136px; left: 136px; width: 128px; }
        .line.h5 { bottom: 10px; left: 10px; width: 380px; }
        /* Lignes Verticales */
        .line.v { width: 4px; }
        .line.v1 { top: 10px; left: 10px; height: 190px; }
        .line.v2 { top: 136px; left: 136px; height: 128px; }
        .line.v3 { top: 10px; left: 200px; height: 380px; }
        .line.v4 { top: 136px; right: 136px; height: 128px; }
        .line.v5 { top: 10px; right: 10px; height: 190px; }
        
        /* Intersections (Points de jeu) */
        .intersection {
            position: absolute;
            width: 24px;
            height: 24px;
            border-radius: 50%;
            background-color: #1a1a2e; 
            border: 3px solid #6441a5; /* Violet néon */
            cursor: pointer;
            z-index: 100;
            /* Centre l'élément */
            transform: translate(-50%, -50%);
            transition: background-color 0.2s;
        }
        .intersection:hover:not(.occupied):not(.removable) {
            background-color: #00ff9950; /* Vert semi-transparent */
        }

        /* Pièces sur le plateau */
        .piece {
            width: 18px;
            height: 18px;
            border-radius: 50%;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            box-shadow: 0 0 8px rgba(0, 0, 0, 0.8);
        }
        .player1 { background-color: #027afa; } /* Bleu (Joueur 1) */
        .player2 { background-color: #FF4136; } /* Rouge (Joueur 2) */
        
        /* Pièce sélectionnée (pour le mouvement) */
        .selected { 
            border: 3px solid #FFDC00; /* Jaune néon pour la sélection */
            box-shadow: 0 0 10px #FFDC00; 
        }
        
        /* Pièce qui peut être retirée */
        .removable {
            border: 3px solid #00ff99; 
            box-shadow: 0 0 10px #00ff99;
            cursor: crosshair;
        }

        /* Compteurs de pièces */
        #counters {
            display: flex;
            justify-content: space-around;
            width: 400px;
            margin-top: 10px;
            font-size: 1.1em;
        }

        /* Indicateur de tour et statut */
        #status { font-size: 1.2em; margin: 15px 0; min-height: 25px; color: #FFDC00; text-align: center; }
        
        /* Boutons et lien */
        button { background-color: #00ff99; border: none; color: #1a1a2e; padding: 10px 20px; font-size: 1em; font-weight: bold; border-radius: 5px; cursor: pointer; margin: 5px; }
        a { display: inline-block; margin-top: 15px; color: #00ff99; text-decoration: none; font-size: 1.1em; }
    </style>
</head>
<body>

    <h1>Jeu du Moulin</h1>
    
    <div id="status"></div>
    
    <div id="board-container">
        <div class="line h h1"></div>
        <div class="line h h2"></div>
        <div class="line h h3"></div>
        <div class="line h h4"></div>
        <div class="line h h5"></div>
        
        <div class="line v v1"></div>
        <div class="line v v2"></div>
        <div class="line v v3"></div>
        <div class="line v v4"></div>
        <div class="line v v5"></div>

        </div>
    
    <div id="counters">
        <span id="p1-counter">Bleu : 9 pièces restantes</span>
        <span id="p2-counter">Rouge : 9 pièces restantes</span>
    </div>

    <div>
        <button id="restartButton">Nouvelle Partie</button>
        <a href="../index.html">Retour au menu</a>
    </div>

    <script>
        // Coordonnées pour le style amélioré (Centre = 200px, 200px)
        const POSITIONS_STYLE = [
            // Ligne 1 (Externe)
            [10, 10], [200, 10], [390, 10],
            [10, 200], [390, 200],
            [10, 390], [200, 390], [390, 390],

            // Ligne 2 (Médiane)
            [73, 73], [200, 73], [327, 73],
            [73, 200], [327, 200],
            [73, 327], [200, 327], [327, 327],
            
            // Ligne 3 (Interne)
            [136, 136], [200, 136], [264, 136],
            [136, 200], [264, 200],
            [136, 264], [200, 264], [264, 264]
        ];

        // Mappage des index de position pour le style
        // 0-2 (Externe Haut), 3-4 (Externe Centre), 5-7 (Externe Bas)
        // 8-10 (Médiane Haut), 11-12 (Médiane Centre), 13-15 (Médiane Bas)
        // 16-18 (Interne Haut), 19-20 (Interne Centre), 21-23 (Interne Bas)
        
        // Connexions entre les intersections (index du 0 à 23)
        // Ces connexions sont basées sur le mapping 24-points standard
        const CONNECTIONS = [
            [0, 1], [1, 2], [3, 4], [5, 6], [6, 7], 
            [8, 9], [9, 10], [11, 12], [13, 14], [14, 15], 
            [16, 17], [17, 18], [19, 20], [21, 22], [22, 23], 
            // Verticales et Centre
            [0, 3], [3, 5], [8, 11], [11, 13], [16, 19], [19, 21],
            [1, 9], [9, 17], [17, 22], [22, 20], [20, 15], [15, 7], 
            [2, 4], [4, 7], [10, 12], [12, 15], [18, 20], [20, 23]
        ];


        // Les lignes qui forment un moulin
        const MILL_LINES = [
            [0, 1, 2], [3, 4, 5], [6, 7, 8], [9, 10, 11], [12, 13, 14],
            [15, 16, 17], [18, 19, 20], [21, 22, 23], // Horizontales
            [0, 9, 21], [3, 10, 18], [6, 11, 15], [1, 4, 7], [16, 19, 22],
            [8, 12, 17], [5, 13, 20], [2, 14, 23] // Verticales et Centre
        ];


        const boardContainer = document.getElementById('board-container');
        const statusElement = document.getElementById('status');
        const p1Counter = document.getElementById('p1-counter');
        const p2Counter = document.getElementById('p2-counter');

        let boardState = new Array(24).fill(0); // 0: vide, 1: P1, 2: P2
        let currentPlayer = 1; 
        let piecesToPlace = { 1: 9, 2: 9 };
        let piecesOnBoard = { 1: 0, 2: 0 };
        let phase = 'PLACEMENT';
        let selectedPosition = -1;
        let gameActive = true;
        let isFlying = { 1: false, 2: false };

        // --- Fonctions d'Initialisation et de Rendu ---

        function initializeGame() {
            boardState = new Array(24).fill(0);
            piecesToPlace = { 1: 9, 2: 9 };
            piecesOnBoard = { 1: 0, 2: 0 };
            currentPlayer = 1;
            phase = 'PLACEMENT';
            selectedPosition = -1;
            gameActive = true;
            isFlying = { 1: false, 2: false };
            
            renderBoard();
            updateStatus();
            updateCounters();
        }

        function renderBoard() {
            document.querySelectorAll('.intersection').forEach(n => n.remove());

            POSITIONS_STYLE.forEach((pos, index) => {
                const node = document.createElement('div');
                node.classList.add('intersection');
                node.style.left = `${pos[0]}px`;
                node.style.top = `${pos[1]}px`;
                node.dataset.index = index;

                const pieceType = boardState[index];
                if (pieceType !== 0) {
                    node.classList.add('occupied');
                    const piece = document.createElement('div');
                    piece.classList.add('piece', `player${pieceType}`);
                    
                    if (selectedPosition === index) {
                         piece.classList.add('selected');
                    }
                    
                    node.appendChild(piece);
                    
                    if (phase !== 'PLACEMENT') {
                        node.addEventListener('click', handlePieceClick);
                    }
                } else {
                    node.classList.remove('occupied');
                    node.addEventListener('click', handleBoardClick);
                }
                
                // Gère la phase de PRISE
                if (phase === 'PRISE' && pieceType !== 0 && pieceType !== currentPlayer) {
                     node.classList.add('removable');
                     node.addEventListener('click', handleRemoveClick);
                }


                boardContainer.appendChild(node);
            });
        }
        
        function updateStatus() {
            let playerColor = currentPlayer === 1 ? 'Bleu' : 'Rouge';
            let phaseText = '';

            switch (phase) {
                case 'PLACEMENT':
                    phaseText = `Phase 1 (Placement). ${playerColor}, placez une pièce. (${piecesToPlace[currentPlayer]} restantes)`;
                    break;
                case 'MOUVEMENT':
                    let action = isFlying[currentPlayer] ? 'vôlez' : 'déplacez-vous';
                    phaseText = `Phase 2 (Mouvement). ${playerColor}, sélectionnez une pièce à ${action}.`;
                    break;
                case 'PRISE':
                    phaseText = `Phase 3 (Prise). ${playerColor}, retirez une pièce adverse.`;
                    break;
                case 'FIN':
                    phaseText = `🏆 FIN : Le joueur ${playerColor} a gagné !`;
                    break;
            }
            statusElement.textContent = phaseText;
        }

        function updateCounters() {
            p1Counter.textContent = `Bleu : ${piecesOnBoard[1]} en jeu (${piecesToPlace[1]} en main)`;
            p2Counter.textContent = `Rouge : ${piecesOnBoard[2]} en jeu (${piecesToPlace[2]} en main)`;
        }


        // --- Logique de Clic ---

        function handleBoardClick(e) {
            if (!gameActive) return;
            const targetIndex = parseInt(e.currentTarget.dataset.index);

            // Phase de PLACEMENT
            if (phase === 'PLACEMENT') {
                if (boardState[targetIndex] === 0 && piecesToPlace[currentPlayer] > 0) {
                    boardState[targetIndex] = currentPlayer;
                    piecesToPlace[currentPlayer]--;
                    piecesOnBoard[currentPlayer]++;
                    
                    if (isMill(targetIndex, currentPlayer)) {
                        phase = 'PRISE';
                    } else {
                        switchTurn();
                    }
                    renderBoard();
                }
            } 
            // Phase de MOUVEMENT (destination)
            else if (phase === 'MOUVEMENT' && selectedPosition !== -1) {
                if (boardState[targetIndex] === 0) {
                    const isValidMove = isFlying[currentPlayer] || isNeighbor(selectedPosition, targetIndex);
                    
                    if (isValidMove) {
                        boardState[targetIndex] = currentPlayer;
                        boardState[selectedPosition] = 0;
                        selectedPosition = -1;

                        if (isMill(targetIndex, currentPlayer)) {
                            phase = 'PRISE';
                        } else {
                            switchTurn();
                            checkGameEnd();
                        }
                        renderBoard();
                    }
                }
            }
        }

        function handlePieceClick(e) {
            if (!gameActive || phase !== 'MOUVEMENT') return;
            const targetIndex = parseInt(e.currentTarget.dataset.index);

            if (boardState[targetIndex] === currentPlayer) {
                // Si on reclique sur la pièce sélectionnée, on désélectionne
                selectedPosition = (selectedPosition === targetIndex) ? -1 : targetIndex;
                renderBoard();
            }
        }

        function handleRemoveClick(e) {
             if (!gameActive || phase !== 'PRISE') return;
             const targetIndex = parseInt(e.currentTarget.dataset.index);
             const opponent = currentPlayer === 1 ? 2 : 1;

             if (boardState[targetIndex] === opponent) {
                  const isOpponentInMill = isMill(targetIndex, opponent);
                  const allOpponentInMills = piecesOnBoard[opponent] <= 3 || areAllPiecesInMills(opponent);
                  
                  if (!isOpponentInMill || allOpponentInMills) {
                     boardState[targetIndex] = 0;
                     piecesOnBoard[opponent]--;

                     switchTurn();
                     checkGameEnd();
                  } else {
                      statusElement.textContent = `Cette pièce fait partie d'un moulin. Trouvez une pièce isolée !`;
                      return;
                  }
             }
        }
        
        // --- Fonctions de Logique de Jeu ---

        function isMill(posIndex, player) {
            return MILL_LINES.some(line => {
                if (line.includes(posIndex)) {
                    return line.every(index => boardState[index] === player);
                }
                return false;
            });
        }
        
        function areAllPiecesInMills(player) {
            for(let i = 0; i < 24; i++) {
                if (boardState[i] === player && !isMill(i, player)) {
                    return false;
                }
            }
            return true;
        }
        
        function isNeighbor(index1, index2) {
            for (const connection of CONNECTIONS) {
                if ((connection[0] === index1 && connection[1] === index2) || 
                    (connection[0] === index2 && connection[1] === index1)) {
                    return true;
                }
            }
            return false;
        }
        
        function switchTurn() {
            selectedPosition = -1;
            currentPlayer = currentPlayer === 1 ? 2 : 1;
            
            if (piecesToPlace[1] === 0 && piecesToPlace[2] === 0) {
                phase = 'MOUVEMENT';
                isFlying[currentPlayer] = (piecesOnBoard[currentPlayer] <= 3);
            }
            
            renderBoard();
            updateStatus();
        }

        function checkGameEnd() {
            const opponent = currentPlayer === 1 ? 2 : 1;
            
            if (piecesOnBoard[opponent] < 3 && phase !== 'PLACEMENT') {
                endGame(currentPlayer);
            }
            // Note: Vérification de blocage non implémentée (trop complexe)
        }
        
        function endGame(winner) {
            gameActive = false;
            phase = 'FIN';
            let winnerColor = winner === 1 ? 'Bleu' : 'Rouge';
            statusElement.textContent = `🏆 FIN : Le joueur ${winnerColor} a gagné !`;
        }

        // --- Événements ---
        restartButton.addEventListener('click', initializeGame);
        
        // Lancement du jeu au chargement de la page
        initializeGame();
    </script>
